笔记使用的单片机为 STC89C52

**编程时添加 #include <reg52.h>  这个头文件, 其他的单片机应该查看厂商资料手册.**

### 数据类型扩充

```c
一共4个寄存器,每个寄存器8位.
数据类型的定义, 必须写在全局,不可以出现在任何函数内, 包括main.
  
sfr  变量名=地址值;   // 特殊功能寄存器声明, P1 就是这个类型, 就是代表一个8位的寄存器
			/* 特殊功能寄存器在 reg51.h 这个头文件里面都定义好了,不要去自定义寄存器的名字 */
sbit 变量名=地址值;   // 特殊功能位声明,是寄存器上面的一个位, 代表8位寄存器的其中一位
			/* 再给某个引脚取名的时候会经常用到. 每个寄存器是8个比特,每个比特使用 ^0 直到 ^7表示 */

```

```c
#include <reg52.h>	
#define led  P1    // 代表的是整个寄存器 8 位,把P1看成设备就好了,不要看成是值运算.
sbit p1_0=P1^0 ;   // 声明LED 代表 P1寄存器,的第0个bit位 的那个针脚, 不要直接修改P1.这不是异或运算

void mian(void) {  
  led=0x00;  /* 点亮所有LED ,P1 上 1-8的所有位的针脚全部输出低电平*/
  led = 0xff ^ 0xf80;  /* 异或运算,0-3点亮输出低电平, 4-7输出高电平 LED不亮.*/
  p1_0=0;     /* P1寄存器,第0bit位针脚, 该引脚输出低电平,点亮二极管 P1.0 */
  while(1);  
}
```

#### 函数

```c
循环左移和循环右移
 #include <intrins.h>
  i = _crol_(i,1);   //将i循环左移一位, 逻辑左移, 将移出的位扔掉,末尾加0
  i = _cror_(i,1);   //将i循环右移一位

```



## LED编程

```c
/*  流水循环亮起8个 LED 灯, P1 寄存器 有8个针脚,分别是 P1^0 到 P1^7 */
#include <reg52.h>
void delay(void){ 	/* 当成计时器来用 */
  int i,j;	
  for(i=112; i>0 ; i--)
    	for(j=122 ; j>0 ; j--);
}
void main(void){
	int i = 0;
  while(1){
		P1 = 0xfe;		/* 这是赋值, 不是定义位置 */
    for ( i=0; i<8; i++){
      delay();
     /*-------*/  /* 下面这两布可以使用 P1=_crol_(P1,1); 来替换.*/
      P1 <<=1 ;		/* 这里进行循环点亮. */
      P1 |= 1;    /* 这里必不可少,否则会同时亮起多个*/
    /*-------*/
    }
  }
}  
```

## 蜂鸣器编程

```c
/* 蜂鸣器默认是 P2^3  这个针脚, P2是寄存器 ,3是寄存器的第三个针脚,低位的 */
#include <reg52.h>
#include <intrins.h>
sbit mf = P2^3;

void delay(unsigned int a){
	unsigned int i,j;
  for(i=a; i>0; i--)
    	for(j=a; j>0; j--);
}
void main(void){
	int n=0;
  P1 = 0xfe;
  while(1){
    if(n == 8){
      n=0;
      P1=0xfe;
    }
    P1=_crol_(P1,1);	 //循环流水灯
    fm=0;		//低电平开
    delay(100);
    fm=1;
    delay(100);
  }
}
```

## 共阴数码管字形码表 编程

```c
/* 数码管字形表, 低电平关,高电平开.
0x3f 0,  0x06 1,  0x5b 2,  0x4f 3,  0x66 4,  0x6d 5,  0x7d 6,  0x07 7,   0x7f 8, 
0x6f 9,  0x77 A,  0x7c B,  0x39 C,  0x5e D,  0x79 E,  0x71 F,  0x00 不显示
*/
/* P0 显示数码管的数字和方式 , 8个针脚 */
/* P2^4, P2^5, P2^6, P2^7  是多组数码管中的哪组点亮, 需要看电路图 */

#include <reg52.h>
unsigned char zi[10] = {
	0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x07d ,0x07, 0x7f, 0x6f  /* 0-9 十个数字 */
};
void delay(int a){
	int j,i;
  for(j=a; j>0; j--)
    	for(i=a; i>0; i--);
}
void main(void){
	int  b = 10;
  while(1){		/* 动态数码管显示, 1234 这四个数字, 不停闪烁,超过人类眼睛极限,就可以实现动态效果 */
    delay(b);
    	P2 = 0x8f;	/* P2 是多组数码管中的哪组点亮 */
    	P0 = zi[3];	/* P0 是数码管显示的数字和方式,8个针脚*/
    	
    delay(b);
    	P2 = 0x4f;
    	P0 = zi[2];
    	
    delay(b);
    	P2 = 0x2f;
    	P0 = zi[1];
    
    delay(b);
    	P2 = 0x1f;
    	P0 = zi[0];
	}
}
```

### 独立键盘输入

```c
/* P3 针脚第二功能表 , P3 口拥有两种功能.一种是普通高低电平, 一种是信号. ( 1高电平,0低电平)
	引脚 	    第二功能
	P3.0    写作 RxD ,串行口接收数据输入端
	P3.1    写作 TxD ,串行口发送数据输出端
	P3.2    写作 INT0 ,外部中断申请输入端 0
  P3.3    写作 INT1 ,外部中断申请输入端 1
	P3.4    写作 T0 ,外部计数脉冲输入端 0
	P3.5    写作 T1 ,外部计数脉冲输入端 1
	P3.6    写作 WR ,写外设控制信号输出端 
	P3.7    写作 RD ,读外设控制信号输出端
*/
/* P3 拥有上拉电阻, 无外接设备的情况下输出高电平 */
/* 靠软件实现的键盘称为非编码键盘, 靠硬件编码器实现的叫编码键盘 */
/* 注意消除 松开与按下 按键时产生的抖动. */
/* P3^4, 5, 6, 7 针脚为按键针脚,默认给出高电平,按键按下后,接通地线 */

#include <reg52.h>
void delay(int a){
  int i,j;
  for(i=a; i>0; i--)
    for(j=a; j>0; j--);
}
void main(void){	 /* 按一次按键就会亮起一个灯, 再次按下就熄灭,长按闪烁 */
  unsigned char t = 0x0f;
  P1 = 0xff;
  while(1){
    while(1){
			t = (P3 >> 4);		/* P3 是按键对应的寄存器上的高四位 */
      if( t == 0x0f)
        continue;
      else
        break;
    }
    P1 = (~(P1 ^ t)) | 0xf0;	   /* 进行运算,得到关闭正在亮的灯还是开启新的灯 */
    delay(120);		/* 变换灯的时间是200 毫秒左右 */
  }
}
```

### 中断服务函数 (要看原理图和官方寄存器资料)

```c
/*  任何情况下都不可以手动调用中断函数, 中断函数不可以传递参数, 中断函数不需要声明.
中断函数的写法:
		void 函数名(void) interrupt 中断编号
		{ 处理中断的函数体内容;  }
		// 这个中断编号和中断次数寄存器(IE)优先级有关 : 
						D0位最高,(中断编号0,程序中代表是EX0,对应针脚为INT0)
						D1位其次,(中断编号1,程序中代表是ET0,对应针脚为T0,自动改变)
						D2位其次,(中断编号2,程序中代表是EX1,对应针脚为INT1)
						D3位其次,(中断编号3,程序中代表是ET1,对应针脚为T1自动改变)
						D4位其次,(中断编号4,程序中代表是ES, 没有针脚)
						D5位最低,(中断编号5,程序中代表是ET2,对应针脚为T2自动改变)
				D7 特殊,为EA 允许接受所有中断的位, 为1时接受,0时拒绝所有外部中断请求.
*/
/* 中断是有优先级的 */
/* 必须开启 中断寄存器IE 中的 EA位为高电平,还有允许中断位(EX0,EX1,ET0,ET1,ET2,ES),才可以接受外部中断请求,否则不接受 */

#include <reg52.h>
void low(void) interrupt 2     /*中断处理函数, 处理 EX1位的信号,针脚为INT1 */
{  P1 = ~P1;  }     /* 随便写点东西 */

/* 只要 P3.3 (INT1)接口, 收到低电平(地线) 就会触发中断,运行 low 函数 */
void main(void){
		P1 = 0x0f;   //设定个默认值,让他亮四个灯
  	EX1 = 1;     //允许 INT1 针脚中断
  	EA = 1;    // 允许全局出现中断并处理
  	IT1 = 1;   //中断触发方式为 下降沿触发, 0是低电平触发
  while(1);
}
```

### 定时器

```c
定时器 也叫计数器 , 是一个16位宽的 由计数脉冲触发的按递增规律(累加)工作循环累加计数器(高位HT0,低位TL0)
  当出现溢出时(65535+1),计数器回0, 同时产生溢出中断请求信号,(TF0置1), 如果 定时器/计数器 
  		工作于定时模式,则表示时间已到.

#include <reg52.h>
int i =0;
sbit led = P1^0;

void timer1_init(){      /* 定时器1 的初始化 */
	TMOD = 0x10;		/* 定时器1 选择工作方式1 */
  TH1 = 0x4c;		  /*设置初始值, 定时 50ms */
  TL1 = 0x00;     
  EA = 1;				  /*打开总中断*/
  ET1 = 1;				/* 打开定时器1 中断 */
  TR1 = 1;        /* 启动定时器 0 */
}

void main(void){
  led = 1;
  timer1_init();
  while(1)
    	if ( i == 10){
        	led = ~led;
        	i=0 ;
      }
}

void timer1() interrupt 3  {
  	TH1 = 0x4c;  /* 还原初始值 , 定时50ms */s
    LT1 = 0x00;
    i++;
}
```

### 串口通信

```c
/*
工作方式寄存器: SCON
  位  D7    D6    D5    D4    D3    D2    D1    D0
功能  SM0   SM1   SM2   REN   TB8   RB8   TI    RI
- RI : 接受中断标志位, 数据接受结束时,硬件自动置1,向CPU发送中断请求.(需要软件复位)
- TI : 发送中断标志位, 数据发送结束时,硬件自动置1,向CPU发送中断请求.(需要软件复位)
- TB8 : 用来存放发送的第9位 
- RB8 : 用来存放接收的第9位 
- REN : 串行接收允许位
	       0时 允许串行接收,  1时 禁止串行接收
- SM0 于 SM1 : 用于设置串行口的工作方式,一共会有4种方式.

SMOD位 是波特率是否加倍的选择位,  0时波特率加倍1/32, 1时不加倍 1/16. (这是硬件的)
*/

#include <reg52.h>

void UsartConfiguration(){    //初始化串口和波特率, 以及中断
	SCON = 0x50;	//设置为 工作方式1
  TMOD = 0x20;  // 设置计数器工作方式2
  PCON = 0x00;  // SMOD=0  , 32分频波特率,就是9600波特率
  TH1 = 0xfd;   // 计数器初始化值设置, 注意波特率时9600的
  TL1 = 0xfd;   
  ES = 1;				// 打开接收中断
  EA = 1;       // 打开总中断
  TR1 = 1;      // 打开计数器
}

void main(void){
   UsartConfiguration();
  while(1);
}

void uart() interrupt 4         //使用ES中断 ,所以优先级是4
{
  unsigned char date;
  
  date = SBUF;    //取出接收到的数据
  RI = 0;        // 清除接收中断标志位 
  SBUF = date;   // 将接收到的数据放回发送缓存器
  while(!TI);    // 等待数据发送完成
  TI = 0;        // 清除发送中断标志位.
```

























